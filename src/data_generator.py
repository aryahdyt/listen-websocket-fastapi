import numpy as np
import pandas as pd
from typing import Tuple, Dict, Any


def _angle_wrap_deg(angle: float) -> float:
    """Wrap angle to [0, 360)."""
    return angle % 360.0


def generate_dummy_tracks(
    n_ais: int = 30,
    n_arpa: int = 35,
    area_size_km: float = 20.0,
    fraction_non_ais: float = 0.3,
    seed: int = 42,
    base_timestamp_s: float = 1_700_000_000.0,
) -> Tuple[pd.DataFrame, pd.DataFrame, Dict[str, Any]]:
    """
    Generate synthetic AIS and ARPA tracks for a single cycle.

    - Coordinates are local ENU in meters inside a square area.
    - AIS tracks are the truth; ARPA matches are generated by perturbing AIS with noise.
    - Additional ARPA tracks (non-AIS) are created randomly.

    Returns:
        ais_df: DataFrame with columns [ais_id, mmsi, x, y, sog_ms, cog_deg, timestamp_s]
        arpa_df: DataFrame with columns [arpa_id, x, y, speed_ms, heading_deg, timestamp_s]
        meta: dict containing ground truth mapping {arpa_id -> ais_id} for matched tracks
    """
    rng = np.random.default_rng(seed)

    area_m = area_size_km * 1000.0

    # Generate AIS truth tracks
    ais_ids = [f"AIS_{i:03d}" for i in range(n_ais)]
    mmsi_vals = rng.integers(200000000, 799999999, size=n_ais)
    ais_x = rng.uniform(0, area_m, size=n_ais)
    ais_y = rng.uniform(0, area_m, size=n_ais)
    ais_speed_ms = rng.uniform(0.0, 8.0, size=n_ais)  # 0â€“~15.5 knots
    ais_heading_deg = rng.uniform(0.0, 360.0, size=n_ais)
    ais_timestamp_s = base_timestamp_s + rng.uniform(-30.0, 30.0, size=n_ais)

    ais_df = pd.DataFrame(
        {
            "ais_id": ais_ids,
            "mmsi": mmsi_vals,
            "x": ais_x,
            "y": ais_y,
            "sog_ms": ais_speed_ms,
            "cog_deg": ais_heading_deg,
            "timestamp_s": ais_timestamp_s,
        }
    )

    # Decide how many ARPA tracks will match AIS
    max_matches = min(n_arpa, n_ais)
    target_matches = int(max_matches * (1.0 - fraction_non_ais))
    target_matches = max(0, min(target_matches, max_matches))

    matched_ais_indices = rng.choice(n_ais, size=target_matches, replace=False)

    # Noise parameters for ARPA derived from AIS
    pos_noise_sigma_m = 70.0
    spd_noise_sigma_ms = 0.5
    hdg_noise_sigma_deg = 5.0
    time_noise_sigma_s = 10.0

    arpa_rows = []
    truth_map: Dict[str, str] = {}

    # Create matched ARPA tracks by perturbing AIS
    for i, ais_idx in enumerate(matched_ais_indices):
        arpa_id = f"ARPA_M_{i:03d}"
        ax = ais_df.loc[ais_idx, "x"] + rng.normal(0.0, pos_noise_sigma_m)
        ay = ais_df.loc[ais_idx, "y"] + rng.normal(0.0, pos_noise_sigma_m)
        aspd = max(
            0.0, ais_df.loc[ais_idx, "sog_ms"] + rng.normal(0.0, spd_noise_sigma_ms)
        )
        ahdg = _angle_wrap_deg(
            ais_df.loc[ais_idx, "cog_deg"] + rng.normal(0.0, hdg_noise_sigma_deg)
        )
        atime = ais_df.loc[ais_idx, "timestamp_s"] + rng.normal(0.0, time_noise_sigma_s)
        arpa_rows.append(
            {
                "arpa_id": arpa_id,
                "x": ax,
                "y": ay,
                "speed_ms": aspd,
                "heading_deg": ahdg,
                "timestamp_s": atime,
            }
        )
        truth_map[arpa_id] = ais_df.loc[ais_idx, "ais_id"]

    # Create additional non-AIS ARPA tracks
    remaining = n_arpa - len(arpa_rows)
    for i in range(remaining):
        arpa_id = f"ARPA_N_{i:03d}"
        # Ensure many non-AIS tracks are not too close to any AIS to reduce accidental matches
        # Sample until outside a minimum distance from all AIS
        min_dist_m = 500.0
        for _ in range(50):
            x = rng.uniform(0, area_m)
            y = rng.uniform(0, area_m)
            dx = x - ais_x
            dy = y - ais_y
            dists = np.sqrt(dx * dx + dy * dy)
            if dists.min() > min_dist_m:
                break
        spd = rng.uniform(0.0, 8.0)
        hdg = rng.uniform(0.0, 360.0)
        t = base_timestamp_s + rng.uniform(-30.0, 30.0)
        arpa_rows.append(
            {
                "arpa_id": arpa_id,
                "x": x,
                "y": y,
                "speed_ms": spd,
                "heading_deg": hdg,
                "timestamp_s": t,
            }
        )

    arpa_df = pd.DataFrame(arpa_rows)

    return ais_df, arpa_df, {"truth_map": truth_map}